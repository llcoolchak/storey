require "storey/version"
require "rails/all"
require "active_support/core_ext/module" # so we can use mattr_accessor
require 'storey/railtie' if defined?(Rails)
require 'storey/exceptions'
require 'storey/migrator'

module Storey
  extend self

  mattr_accessor :suffix, :default_search_path
  mattr_reader :excluded_models

  def init
    puts "Saving @@default_search_path: #{schema}"
    @@default_search_path = schema
    self.excluded_models ||= []
    process_excluded_models
  end

  def excluded_models=(array)
    @@excluded_models = array
    process_excluded_models
  end

  def schema(options={})
    options[:suffix] ||= false

    name = ActiveRecord::Base.connection.schema_search_path

    if options[:suffix]
      name
    else
      unsuffixify name
    end
  end

  def create(name, options={}, &block)
    options[:load_database_schema] = true unless options.has_key?(:load_database_schema)

    name = suffixify(name)
    ActiveRecord::Base.connection.execute "CREATE SCHEMA #{name}"
    switch name do
      load_database_schema if options[:load_database_schema] == true
      block.call if block_given?
    end
  rescue ActiveRecord::StatementInvalid => e
    raise Storey::SchemaExists, %{The schema "#{name}" already exists.}
  end

  def schemas(options={})
    options[:suffix] ||= false
    options[:public] = true unless options.has_key?(:public)

    sql = "SELECT nspname FROM pg_namespace"
    sql << " WHERE nspname !~ '^pg_.*'"
    sql << " AND nspname !~ 'information_schema'"
    sql << " AND nspname !~ 'public'" unless options[:public]

    names = ActiveRecord::Base.connection.query(sql).flatten

    if options[:suffix]
      names
    else
      names = names.map {|name| unsuffixify(name)}
    end
  end

  def drop(name)
    name = suffixify name
    ActiveRecord::Base.connection.execute("DROP SCHEMA #{name} CASCADE")
  rescue ActiveRecord::StatementInvalid => e
    raise Storey::SchemaNotFound, %{The schema "#{name}" cannot be found.}
  end

  def switch(name=nil, &block)
    if block_given?
      original_schema = schema
      switch name
      result = block.call
      puts "result saved. about to switch back to #{original_schema}."
      switch original_schema
      puts "Switched back to #{original_schema}. will return #{result}"
      result
    else
      puts "Will reset if name is blank. name: #{name}. blank? #{name.blank?}"
      reset and return if name.blank?
      puts "done resetting. name is not blank, it's: #{name}"
      name = suffixify name
      puts "suffixified name: #{name}"
      ActiveRecord::Base.connection.schema_search_path = name
      puts "Just set schema_search_path to #{name}"
    end
  rescue ActiveRecord::StatementInvalid => e
    if e =~ /relation "([^"]+)" does not exist/
      raise Storey::TableNotFound, %{The schema "#{name}" does not have the table #{$1}.}
    elsif e =~ /invalid value for parameter "search_path"/
      raise Storey::SchemaNotFound, %{The schema "#{name}" cannot be found.}
    else
      raise StandardError, e
    end
  end

  def reload_config!
    self.excluded_models = []
    self.suffix = nil
  end

  protected

  def schema_migrations
    ActiveRecord::Migrator.get_all_versions
  end

  def reset
    puts "#reset schema_search_path = #{self.default_search_path}. Here are the schemas: #{schemas.inspect}"
    ActiveRecord::Base.connection.schema_search_path = self.default_search_path
  end

  # Loads the Rails schema.rb into the current schema
  def load_database_schema
    puts "#load_database_schema into #{schema}"
    #ActiveRecord::Schema.verbose = false # do not log schema load output.
    load_or_abort("#{Rails.root}/db/schema.rb")
    puts "Done #load_database_schema #{schema}"
  end

  def load_or_abort(file)
    if File.exists?(file)
      load(file)
    else
      abort %{#{file} doesn't exist yet}
    end
  end

  def suffixify(name)
    if Storey.suffix && !name.include?(Storey.suffix) && name != self.default_search_path
      "#{name}#{Storey.suffix}"
    else
      name
    end
  end

  def unsuffixify(name)
    Storey.suffix && name =~ /(\w+)#{Storey.suffix}/ ? $1 : name
  end

  def process_excluded_models
    self.excluded_models.each do |model_name|
      model_name.constantize.tap do |klass|
        # Resetting column information removes previous setting of schemas in table_name
        #klass.reset_column_information
        table_name = klass.table_name.split('.', 2).last
        klass.table_name = "public.#{table_name}"
      end
    end
  end
end
